# Java source files generator and bytecode manipulation
This project implements following simple example features:
* Java source generation, the java source code generated will be used by `javaCompile` task.
* Bytecode manipulation on existing classes

### Usage
Apply example project provided in the repository:
```
plugins {
    id("com.gradle.example.rewritekey")
}
```
### Java source generation
Register new task extending from `JavaGeneratorTask`(task included in the plugin):

```
tasks.register<com.gradle.example.codegenerator.JavaGeneratorTask>("javaGeneratorTask") {
    packageName.set("com.example.gradle")
    classes.set(
        mapOf(
            "Example" to "class Example { public String getApiKey() {return \"ANOTHER_DEPLOYMENT_KEY\"; } }",
            "ExampleNoApiKey" to "class ExampleNoApiKey { }",
        )
    )
    outputDirectory.set(layout.projectDirectory.dir("generated/java"))
}
```
We need to set:
* packageName: Name of the package used in the java source files
* classes: A map that represents a name and the content of the java source file
* outputDirectory: Where the java source files are going to be generated

Additionally, we need to wire the output of the task with the `javaCompile` task, we need to define:
```
java.sourceSets["main"].java.srcDir(tasks.named("javaGeneratorTask"))
```
Once we execute task involving the java source set, the source file is generated in the outputDirectory:
```
package com.example.gradle;
/*
*
* Code generated by the awesome task
*
*/
class ExampleNoApiKey { }
```
If we inspect the jar generated by the example project we observe that includes the classes generated:
```
‚ùØ jar -xvf example/build/libs/example.jar
  created: META-INF/
 inflated: META-INF/MANIFEST.MF
  created: com/
  created: com/example/
  created: com/example/gradle/
 inflated: com/example/gradle/Example.class
 inflated: com/example/gradle/ExampleNoApiKey.class
 inflated: com/example/HelloExample.class
```
### Bytecode manipulation on existing classes
The plugin includes an example on how to rewrite existing classes at the bytecode level. We are using ByteBuddy. This library
allows to define custom plugins with our requirements:
```
 override fun apply(
        builder: DynamicType.Builder<*>, typeDescription: TypeDescription, classFileLocator: ClassFileLocator
    ): DynamicType.Builder<*> {
        return builder.method(named("getApiKey")).intercept(FixedValue.value("ProductionKey"))
    }
```
In this example, we are replacing the content of the method `getApiKey` with a production key. ByteBuddy Gradle plugin implements
the logic to wire the different outputs in the compiler tasks required. The bytecode generated after the transformation tasks are applied would be:
```
package com.example;

public final class HelloExample {
    public HelloExample() {
    }

    public String getApiKey() {
        return "ProductionKey";
    }
}
```
The original source file was:
```
    public String getApiKey() {
       return "DEPLOYMENT_KEY";
    }
```




